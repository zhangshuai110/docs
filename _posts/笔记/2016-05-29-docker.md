---
layout: post
title: docker使用笔记
category: 笔记
tags: 笔记 docker
keywords: docker
description: 
---

# 安装  
  
# 命令  
  
- 搜索镜像（ search）  
命令行的格式为：docker search 镜像名字
- 列出所有镜像(images)  
 docker images  
- 列出正在运行的(容器)containers  
 docker ps  
- 列出所有的容器  
 docker ps -a   
- 下载镜像  
 docker pull ubuntu  
 指定仓库下载镜像：docker pull d1.dockerpool.com:5000/ubuntu:12.04  
 之后再创建一个容器，让其中运行bash应用： docker run -t -i ubuntu:12.04 /bin/bash  
- 运行ubuntu镜像  
 docker run -i -t ubuntu /bin/bash   
- 提交变更  
docker commit -m '说明' 3a09b2588478 ubuntu:mynewimage 提交你的变更，并且把容器保存成Tag为mynewimage的新的ubuntu镜像.(注意，这里提交只是提交到本地仓库，类似git)  
  
- 建立映像文件  
  docker build --rm=true -t hjue/lamp .  
  –rm 选项是告诉Docker在构建完成后删除临时的Container，Dockerfile的每一行指令都会创建一个临时的Container，一般你是不需要这些临时生成的Container  
- 把 mynewimage 镜像保存成 tar 文件  
  docker save mynewimage | bzip2 -9 -c> /home/save.tar.bz2  
  
- 加载 mynewimage 镜像  
  bzip2 -d -c < /home/save.tar.bz2 | docker load  
- 删除所有容器  
  docker rm ''docker ps -a -q'  
- 删除镜像  
  docker rmi [image-id]  
- 帮助  
  docker run --help  
- 导出Image  
  docker export <CONTAINER ID> > /home/export.tar  
- 导入Image镜像  
  cat /home/export.tar | sudo docker import - mynewimage  
  
# Dockerfile  
  
  使用docker build来创建一个新的镜像。为此，首先需要创建一个Dockerfile，包含如何创建镜像得指令。  
  
## Dockerfile 实例1  
  
~~~  
# This is a comment  
#告诉docker以哪个Docker镜像作为基础版本  
  FROM ubuntu:14.04  
  #本镜像的维护信息  
  MAINTAINER Docker zhangshuai <tozhangshuai@qq.com>  
# 以RUN开头的指令会在创建中运行，比如安装一个软件包，  
# 在这里使用apt-get来安装了一些软件  
  RUN apt-get -qq update  
  RUN apt-get -qqy install ruby ruby-dev  
  RUN gem install sinatra  
~~~  
  
## Dockerfile 实例2  
~~~  
  # 第一部分开始，基础镜像信息  
  # This  dockerfile  uses  the ubuntu  image  
  # VERSION 2 - EDITION 1  
  
  # 第二部分开始，维护者信息  
  # Author: docker_user  
  
  # 第三部分开始，镜像操作指令  
  # Command format: Instruction [arguments  / command]  ..  
  # Base  image to  use,  this  must  be  set as  the first line  
  FROM  ubuntu  
  # Maintainer: docker_user <docker_user  at  email.com>  (@docker_user)  
  MAINTAINER  docker_user docker_user@email.com  
  # Commands  to  update  the image  
  RUN echo  "deb  http://archive.ubuntu.com/ubuntu/ raring  main  universe" >>  /etc/apt/sources.list  
  RUN apt-get update  &&  apt-get install -y  nginx  
  RUN echo  "\ndaemon off;" >>  /etc/nginx/nginx.conf  
  # 第四部分开始，容器启动时执行的指令  
  # Commands  when  creating  a new container  
  CMD /usr/sbin/nginx  
~~~  
  
## 语法  
  
### 使用#来注释  
  
### FROM指令告诉Docker使用哪个镜像作为基础  
  格式为： FROM <image> 或 FROM <image>:<tag>  
  Dockefile中，第一条指令必须以FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（每个镜像一次）。  
  
### MAINTAINER  
  
  接着是维护者的信息  
  
### RUN开头得指令会在创建中运行，比如安装一个软件包，在这里使用apt-get来安装了一些软件;  
  
  格式为 RUN <command> 或 RUN ["executable", "param1", "param2"]。  
  
  前者将在shell终端中运行命令，即/bin/sh -c；后者则使用exec执行。指定使用其他终端可以通过第二种方式实现，例如： RUN ["/bin/bash", "-c", "echo hello"] 。  
  每条RUN指令将在当前镜像基础上执行制定命令，并且提交为新得镜像。当命令较长时可以使用\来换行。  
  
### CMD  
  
  支持三种格式：  
  
- CMD ["executable", "param1", "param2"] 使用exec执行，推荐使用；  
- CMD command param1 param2 在执行/bin/sh中执行，提供给需要交互的应用；  
- CMD ["param1", "param2"]提供给ENTRYPOINT的默认参数；  
  
指定启动容器时执行的命令，每个Dockerfile只能有一条CMD命令。如果制定了多条命令，只有最后一条会被执行。  
如果用户启动容器时指定了运行的命令，则会覆盖掉CMD命令。  
  
### EXPOSE  
  
  格式为EXPOSE <port> [<port>...]。  
  告诉Docker服务容器暴露得端口号，供互联系统使用。在启动容器时需要通过-P，Docker主机会自动分配一个端口转发到指定得端口。  
  
### ENV  
  
  格式为 ENV <key> <value>。指定一个环境变量，会被后续RUN指令使用，并在容器运行时保存。  
  例如：  
  
~~~  
  ENV PG_MAJOR  9.3  
  ENV PG_VERSION  9.3.4  
  RUN curl  -SL http://example.com/postgres-$PG_VERSION.tar.xz  | tar -xJC  /usr/src/postgress  &&  ...  
  ENV PATH  /usr/local/postgres-$PG_MAJOR/bin:$PATH  
~~~  
  
### ADD  
  
  格式为 ADD <src> <dest>。  
  该命令将复制指定的<src>到容器中的<dest>。其中<src>可以是Dockerfile所在目录的一个相对路径；也可以是一个URL；还可以是一个tar文件（自动解压为目录）。  
  
### COPY  
  
  格式为COPY <src> <dest>。  
  复制本地主机的<src>（为Dockerfile所在目录的相对路径）到容器中得<dest>。  
  当使用本地目录为源目录时，推荐使用COPY。  
  
### ENTRYPOINT  
  
  两种格式：  
  - ENTRYPOINT ["executable", "param1", "param2"]  
  - ENTRYPOINT command param1 param2 （shell中执行）。  
  配置容器启动后执行的命令，并且不可被docker run提供得参数覆盖。  
  每个Dockerfile中只能有一个ENTRYPOINT，当指定多个时，只有最后一个起效。  
  
### VOLUME  
  
  格式为VOLUME ["/data"]  
  创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持得数据等。  
  
### USER  
  
  格式为USER daemon。  
  指定运行容器时的用户名或UID，后续的RUN也会使用指定用户。  
  当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在创建所需要得用户，例如：RUN groupadd -r postgres && useradd -r -g postgres postgres。要临时获取管理员权限可以使用gosu，而不推荐使用sudo。  
  
#### WORKDIR  
  
  格式为 WORKDIR /path/to/workdir  
  为后续得RUN、 CMD、 ENTRYPOINT指令配置工作目录。  
  可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。列如：  
  
~~~  
  WORKDIR /a  
  WORKDIR b  
  WORKDIR c  
  RUN pwd  
  最终路径为 /a/b/c。  
~~~  
  
### ONBUILD  
  
  格式为 ONBUILD [INSTRUCTION]。  
  配置当前所创建得镜像作为其他新创建镜像得基础镜像时，所执行得操作指令。  
  例如，Dockerfile使用如下内容创建了镜像image-A。  
  
~~~  
  [...]  
  ONBUILD ADD . /app/src  
  ONBUILD RUN /usr/local/bin/python-build --dir /app/src  
  [...]  
~~~  
  
  如果基于image-A创建新得镜像时，新的Dockerfile中使用FROM image-A 指定基础镜像时，会自动执行ONBUILD指令内容，等价于在后面添加了两条指令。  
  
~~~  
FROM image-A  
  
#Automatically run the following  
ADD . /app/src  
RUN /usr/local/bin/python-build --dir /app/src  
~~~  
  
使用ONBUILD指令的镜像，推荐在标签中注明，例如ruby:1.9-onbuild。  
  
## 创建镜像命令  
  
  格式为 docker build [选项] 路径，该命令将读取指定路径下（包括子目录）的Dockerfile，并将该路径下得所以内容发送给Dockerfile服务端，有服务端来创建镜像。因此一般建议放置Dockerfile的目录为空目录。也可以通过.dockerignore文件（每一行添加一条匹配模式）来让Docker忽略该路径下得目录和文件。  
  要指定镜像的标签信息，可以通过-t选项，例如  
  docker build -t myrepo/myapp /tmp/test1  
  
  
## sudo docker build -t = "ouruser/sinatra:v2" .  
  
  其中 -t，标记来添加；  
      tag，指定新的镜像的用户信息；  
      "."，是 Dockerfile  所在的路径(当前目录),也可以替换为一个具体的 Dockerfile 的路径；  
  
## 说明  
  
可以看到  build 进程在执行操作。它要做的第一件事情就是上传这个 Dockerfile  内容,因为所有的操作都要依据  Dockerfile  来进行。  然后,Dockfile 中的指令被一条一条的执行。每一步都创建了一个新的容器,在容器中执行指令并提交修改(就跟之前介绍过的 docker  commit 一样)。当所有的指令都执行完毕之  
后,返回了最终的镜像  id。所有的中间步骤所产生的容器都被删除和清理了。  
*注意一个镜像不能超过 127 层  
此外,还可以利用 ADD 命令复制本地文件到镜像;用   EXPOSE    命令来向外部开放端口;用    CMD   命令来描述容器启动后运行的程序等。  
  
# 容器  
  
容器是独立运行得一个或一组应用，以及他们得运行状态环境。对应的，虚拟机可以理解为模拟运行得一套操作系统（提供了运行态环境和其他系统环境）和跑在上面得应用。  
  
## 启动容器  
  
  启动容器有两种方式，一种是基于镜像新建一个容器并启动，另一个是将在终止状态（stopped）的容器重新启动。  
  
### 新建并启动  
  
  所需要得命令主要为docker run。  
  例如，下面的命令输出一个"Hello World"，之后终止容器。  
  
~~~  
  $ docker run ubuntu:14.04 /bin/echo 'Hello world'  
  Hell world  
~~~  
  
  下面一个命令则启动一个bash终端，允许用户进行交互。  
  $ docker run -t -i ubuntu:14.04 /bin/bash  
  root@af8bae53bdd3:/#  
  其中，-t选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器得标准输入上，-i则让容器得标准输入保存打开。  
  在交互模式下，通过终端可以使用的命令有：  
  bin, boot, dev, etc, home, lib, lib64, media, mnt, opt, proc, root, run, sbin, srv, sys, tmp, usr, var  
  
利用docker run来创建容器时，Docker在后台运行得标准操作包括：  
  
-检查本地是否存在指定得镜像，不存在就从共有仓库下载  
-利用镜像创建并启动一个容器  
-分配一个文件系统，并在只读得镜像层外面挂载一层可读写层  
-从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去  
-从地址池配置一个ip地址给容器  
-执行用户指定得应用程序  
-执行完毕后容器被终止  
  
## 启动已终止容器  
  
可以利用docker start命令，直接将一个已终止的容器启动运行。  
容器的核心为所执行得应用程序，所需要的资源都是应用程序运行所必需得。除此之外，并没用其他的资源。可以在伪终端中利用ps或top来查看进程信息。  
  
## 守护状态  
  
更多时候，需要让Docker容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加-d参数来实现。  
例如下面的命令会在后台运行容器  
  
~~~  
$ sudo  docker  run -d  ubuntu:14.04  /bin/sh -c  "while  true; do  echo  hello world;  sleep 1;  done"  
1e5535038e285177d5214659a068137486f96ee5c2e85a4ac52dc83f2ebe4147  
~~~  
  
容器启动后，会返回一个唯一的id可以通过docker ps命令来查看容器信息。  
  
~~~  
$ sudo  docker  ps  
CONTAINER ID    IMAGE                 COMMAND                             CREATED               STATUS              PORTS NAMES  
1e5535038e28    ubuntu:14.04    /bin/sh -c  'while  tr    2 minutes ago   Up  1 minute                insane_babbage  
~~~  
  
要获取容器得输出信息，可以通过docker logs命令。  
  
~~~  
$ sudo  docker  logs  insane_babbage  
hello world  
hello world  
hello world  
. . .  
~~~  
  
## 终止容器  
  
可以使用docker stop来终止一个运行中的容器。  
此外，当Docker容器中指定的应用终止时，容器也自动终止。  
使用docker ps -a命令查看容器状况。  
处于终止状态的容器，可以通过docker start命令来重新启动。  
此外，docker restart命令会将一个运行态的容器终止，然后再重新启动它。  
  
## 进入容器  
  
在使用-d参数时，容器启动后会进入后台。某些时候进入容器进行操作，有很多方法，包括使用 docker attach 命令或 nsenter 工具。  
  
### attach命令  
  
docker attach是Docker自带得命令。下面示例如何使用该命令。  
  
~~~  
➜  sinatra nano Dockerfile   
➜  sinatra docker run -idt ubuntu  
652f4893645f92693cbdcaca00a766b491715c18dd94e5784a63f88e8e9cc384  
➜  sinatra docker ps  
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES  
652f4893645f        ubuntu:latest       "/bin/bash"         5 seconds ago       Up 4 seconds                            reverent_pike         
➜  sinatra docker attach reverent_pike  
root@652f4893645f:/#  
~~~  
  
### 使用nsenter工具  
  
本机实验没用通过，以后再试  
  
## 导出容器  
  
如果想导出本地某个容器，可以使用docker export命令。  
  
~~~  
$ sudo  docker  ps  -a  
CONTAINER ID                IMAGE                             COMMAND                         CREATED                         STATUS                                
7691a814370e                ubuntu:14.04                "/bin/bash"                 36  hours ago               Exited  (0) 21  hours a  
$ sudo  docker  export  7691a814370e  > ubuntu.tar  
~~~  
  
这样接啊ing容器快照到本地文件  
  
## 导入容器快照  
使用docker import从容器快照文件中再导入为镜像，例如：  
  
~~~  
$ cat ubuntu.tar  | sudo  docker  import  - test/ubuntu:v1.0  
$ sudo  docker  images  
REPOSITORY                    TAG                                 IMAGE ID                        CREATED                           VIRTUAL SIZE  
test/ubuntu                 v1.0                                9d37a6082e97                About a minute  ago     171.3 MB  
~~~  
  
此外,也可以通过指定  URL 或者某个目录来导入,例如  
$sudo docker  import  http://example.com/exampleimage.tgz example/imagerepo  
*注:用户既可以使用    docker  load    来导入镜像存储文件到本地镜像库,也可以使用   docker  import    来  
导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息  
(即仅保存容器当时的快照状态),而镜像存储文件将保存完整记录,体积也要大。此外,从容器快照文  
件导入时可以重新指定标签等元数据信息。  
  
# Docker 数据管理  
  
Docker内部及容器间有两种方式共享数据，数据卷（Data volumes）和数据卷容器（Data volume containers）  
  
## 数据卷  
  
  数据卷是一个可供一个或多个容器使用的特殊目录，它绕过UFS，可以提供很多有用的特性：  
  数据卷的使用，类似于Linux下对目录或文件进行mount  
-数据卷可以在容器之间共享和重用  
-对数据卷的修改会立马生效  
-对数据卷的更新，不会影响镜像  
-卷会一直存在，直到没用容器使用  
  
### 创建一个数据卷  
  
在用docker run命令的时候，使用-v标记来创建一个数据卷并挂载到容器里。在一次run中多次使用可以挂载多个数据卷。  
下面创建一个web容器，并加载一个数据卷到容器得/webapp目录。  
docker run -d -P --name web -v /webapp training/webapp python app.py  
*注意：也可以在Dockerfile中使用VOLUME来添加一个或者多个新的卷到由该镜像创建的任意容器。  
### 挂载一个主机目录作为数据卷  
使用-v标记也可以指定挂载一个本地主机的目录到容器中去。  
docker  run -d  -P  --name  web -v  /src/webapp:/opt/webapp training/webapp python  app.py  
上面的命令加载主机的/src/webapp目录到容器的/opt/webapp目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录得路径必须是绝对路径，如果目录不存在，Docker会自动为你创建它。  
注意：Dockerfile中不支持这种用法，这是因为Dockerfile是为了移植和分享用的。然而，不同操作系统的路径格式不一样，所以目录还不能支持。  
Docker挂载数据卷的默认权是读写，用户也可以通过:ro指定为只读。  
docker  run -d  -P  --name  web -v  /src/webapp:/opt/webapp training/webapp python  app.py  
加了:ro之后，就挂载为只读了。  
  
### 挂载一个本地主机文件作为数据卷  
  
 -v然后，其他容器中使用--volumesfrom来挂载dbdata容器中的数据卷。 标记也可以从主机挂载单个文件到容器中  
docker  run --rm  -it -v  ~/.bash_history:/.bash_history  ubuntu  /bin/bash  
这样就可以记录在容器输入过得命令。   
*注意:如果直接挂载一个文件,很多文件编辑工具,包括    vi    或者    sed --in-place   ,可能会造成文件inode 的改变,从 Docker  1.1 .0起,这会导致报错误信息。所以最简单的办法就直接挂载文件的父目录。  
  
## 数据容器  
  
如果你有一些持续更新的数据需要在容器之间共享，最后创建数据容器。  
数据容器，其实就是一个正常的容器，专门用例提供数据卷供其他容器挂载的。  
首先，创建一个命名的数据容器dbdata：  
docker  run -d  -v  /dbdata --name  dbdata  training/postgres echo  Data-only container for postgres  
然后，其他容器中使用--volumesfrom来挂载dbdata容器中的数据卷。  
docker run -d --volumes-from dbdata --name db1 training/postgres  
docker run -d --volumes-from dbdata--name db2 training/postgres  
还可以使用多个--volumes-from参数来从多个容器挂载多个数据卷。也可以从其他已经挂载了数据卷的容器来挂载数据卷。  
docker run -d --name db3 --volumes-from db1 training/postgres  
*注意：使用--volumens-from 参数所挂载数据卷的容器自己并不需要保持在运行状态。  
如果删除了挂载的容器（包括dbdata、db1和db2），数据卷并不会自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用docker rm -v命令来指定同时删除关联的容器。着可以让用户在容器自己升级和移动数据卷。  
  
# docker 中的网络  
  
容器中可以运行一些网络应用，要让外部可以访问这些应用，可以通过-P或-p参数来指定端口映射。当标记为-P时，Docker会随机映射一个49000~49900的端口到内部容器开发网络端口。    
可以使用docker ps可以看到，本地主机的49155被映射到了容器的5000端口 。此时访问本机的49155端口即可访问容器内web应用提供的界面。  
docker  run -d  -P  training/webapp python  app.py    
docker  ps  -l  
CONTAINER ID    IMAGE                                     COMMAND             CREATED               STATUS                PORTS                               
bc533791f3f5    training/webapp:latest    python  app.py  5 seconds ago   Up  2 seconds   0.0.0.0:49155->5000/  
同样的,可以通过    docker  logs    命令来查看应用的信息。  
$ docker  logs  -f  nostalgic_morse  
* Running on  http://0.0.0.0:5000/  
10.0.2.2  - - [23/May/2014  20:16:31] "GET  / HTTP/1.1" 200 -  
10.0.2.2  - - [23/May/2014  20:16:31] "GET  /favicon.ico  HTTP/1.1" 404 -  
-p(小写的)则可以指定要映射的端口,并且,在一个指定端口上只可以绑定一个容器。支持的格式有  
  ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort   。  
  
# 基本操作  
  
## Docker去sudo  
  
在buntu下，在执行Docker时，每次都要输入sudo，同时输入密码，这里把当前用户执行权限添加到相应的docker用户组里面。  
  
### 添加一个新的docker用户组  
  
sudo groupadd docker  
  
### 添加当前用户到docker用户组里，注意这里的king为ubuntu登录用户名  
  
sudo gpasswd -a king docker  
  
### 重启Docker后台监护进程  
  
sudo service docker restart  
  
### 重启之后，尝试一下，是否生效  
  
docker version  
  
### 若还未生效，则系统重启，则生效  
  
sudo reboot  
  
## 下载Ubuntu镜像  
  docker pull ubuntu:14.04  
  
  
  
